## prac 1
![image](https://github.com/user-attachments/assets/391517d7-2a18-4397-901b-2336cd49e396)
## prac 2
![image](https://github.com/user-attachments/assets/b005a41f-8f05-4c73-8c3e-a4135d9b845d)
![image](https://github.com/user-attachments/assets/6c136af2-7a07-4a6c-a3be-33568e0a1f96)
## prac 3
![image](https://github.com/user-attachments/assets/e9da3857-cc87-441f-9489-897bcbffce9c)
## prac 4
![image](https://github.com/user-attachments/assets/320f664a-ca9f-45cd-9228-2893a3b709e4)
## prac5
![image](https://github.com/user-attachments/assets/e5b702f2-7d4f-46ab-8cdd-b2242b5cf776)

## prac 6
![image](https://github.com/user-attachments/assets/02998ed9-18bf-44f5-80c9-2d3721c940f8)

## prac7
![image](https://github.com/user-attachments/assets/2c375256-cfdf-4ce9-8174-1c540d569e0b)

## prac 8
![image](https://github.com/user-attachments/assets/af6e5a89-3fa6-48e2-9b39-d5f772ea97ff)
![image](https://github.com/user-attachments/assets/024cf879-fe1a-4d9f-ad0a-60a5f67a8759)

## prac9

## prac 10
![image](https://github.com/user-attachments/assets/cf3f9186-3df7-41ab-8d3b-e62be5a2e4ac)

## prac  11
![image](https://github.com/user-attachments/assets/74b5ffda-0c33-44da-bfa0-d37509ea0003)

## prac 12
![image](https://github.com/user-attachments/assets/6fee978d-9915-4650-8219-53bb86bde6ae)

## prac 13
![image](https://github.com/user-attachments/assets/de88e0e4-f400-44fb-a78e-7dbc2ec96509)
![image](https://github.com/user-attachments/assets/020b1d9c-049e-428a-9f05-b48f82bf616c)

## prac 14
![image](https://github.com/user-attachments/assets/24acf634-9b7f-41d7-b209-0313e5a1c2ca)
![image](https://github.com/user-attachments/assets/6792f022-524e-4b98-a53b-4670ce39b43c)

## prac 15
![image](https://github.com/user-attachments/assets/80451e88-4879-4caa-94c5-4bdfa867bc89)
![image](https://github.com/user-attachments/assets/571cc6af-4160-48b3-91a6-2429c7452d5c)
![image](https://github.com/user-attachments/assets/fe9fc3c4-39cd-4fbc-8e56-7a4ab5a7b7f3)
![image](https://github.com/user-attachments/assets/f4b54e50-4b2d-46f7-b20a-e6c5ddd9caae)

## prac 16
![image](https://github.com/user-attachments/assets/13d6f6fc-7307-4cfa-b098-7f32f2f42834)
![image](https://github.com/user-attachments/assets/f0573d08-9e65-49ee-b8f2-a4e934341bde)
![image](https://github.com/user-attachments/assets/193e29b2-3d9c-40b1-b59c-5b79f79e2269)

## prac 17
![image](https://github.com/user-attachments/assets/73f28e2b-4173-4bec-997f-5533db8f36a3)
![image](https://github.com/user-attachments/assets/c9ae417b-7f60-4704-8d0e-ff41dc7c6779)

## prac 18
![image](https://github.com/user-attachments/assets/55c7c503-9e3d-4163-8379-9c3b1de679f0)
![image](https://github.com/user-attachments/assets/06398ff4-edf0-4b31-9d88-e70be0c2b494)
![image](https://github.com/user-attachments/assets/b67cdc53-72ed-4684-a95b-6a8bcd575874)

# prob-practical

## que 1.
![Screenshot 2025-04-16 123458](https://github.com/user-attachments/assets/79a57fcf-63b7-418d-b630-99ad6ae42968)

![Image](https://github.com/user-attachments/assets/17516dd2-e3f9-4483-9fb1-b8a842420c42)

![Screenshot 2025-04-16 133348](https://github.com/user-attachments/assets/5efb6e07-ca06-49f6-90cc-9f7dd90ba35f)

## que 2 
![Screenshot 2025-04-16 124704](https://github.com/user-attachments/assets/f56d3025-23b4-4497-b4a5-43fb3a4b775b)

![Screenshot 2025-04-16 211808](https://github.com/user-attachments/assets/75fe095e-50fc-416d-9c1c-d9711e5d85d0)

## que 3
![Screenshot 2025-04-16 125321](https://github.com/user-attachments/assets/49233bce-3a31-4f49-9894-8e4e9ea2ab70)

## que 4
![Screenshot 2025-04-16 130028](https://github.com/user-attachments/assets/d337a64b-39c7-4ab6-bbda-e4eead2fd4a6)

## que 5
![Screenshot 2025-04-16 130535](https://github.com/user-attachments/assets/b48c9610-9d6b-4cc2-8d8a-fd89800fc48b)

## que 6
![Screenshot 2025-04-16 131205](https://github.com/user-attachments/assets/7c6512e2-e58b-41d2-be46-a7adfb725f41)

## que 7
![Screenshot 2025-04-16 132324](https://github.com/user-attachments/assets/8c0e3fba-9004-4882-9c84-75d0230409fa)

## que 8
![Screenshot 2025-04-16 132455](https://github.com/user-attachments/assets/4989fcd4-6c57-4444-81fc-36c999452916)

## que 9
![Screenshot 2025-04-16 205759](https://github.com/user-attachments/assets/97492a20-c338-43c7-89bb-2e87cba02b34)

## que 10
![Screenshot 2025-04-19 233548](https://github.com/user-attachments/assets/2ded5c00-40ed-47bc-b142-adea38ea16ef)

## que 11
![Screenshot 2025-04-19 233152](https://github.com/user-attachments/assets/4005e03f-5511-4af3-92d2-26ffba9bb2fd)

## que 12
![Screenshot 2025-04-19 234140](https://github.com/user-attachments/assets/6e9eae75-cbb9-41fa-8278-36512b07abd4)

## que 13
![image](https://github.com/user-attachments/assets/b592bbc3-ab91-4233-9172-e48c9ef97be7)

## que 14
![Screenshot 2025-04-16 134712](https://github.com/user-attachments/assets/df2c1d8e-5bbe-40c1-9621-3cd8dcfca8e6)

## que 15
![image](https://github.com/user-attachments/assets/6f6eb025-9dbb-4811-b9f1-fdcc2d08f9ef)

## que 16 ( ALL 3 PICS ARE ANSWER OF QUE )
![image](https://github.com/user-attachments/assets/a443edf2-c3ee-41ea-9e7a-ff3cca959f62)

![image](https://github.com/user-attachments/assets/1c91e679-5d4b-4cac-ad71-061011306d2f)

![image](https://github.com/user-attachments/assets/e1e3b11d-b963-49ba-9800-ce188b678120)

## que 17 ( ALL 2 PICS ARE ANSWER OF QUE )
![image](https://github.com/user-attachments/assets/3b3a09cf-d2b2-4232-8c3c-a609b20e9a2d)

![image](https://github.com/user-attachments/assets/4cfd1645-5d86-4c50-ba74-dff782bb15c7)

## que 18
![image](https://github.com/user-attachments/assets/b0600ff8-b596-4b27-aa62-42478cd87f2d)

can use this data :-
```
product Bought	P(x)	log2(P(x))	H(x)
Milk	 0.4	=LOG(0.4,2)	=-0.4*LOG(0.4,2)
Bread	0.35	=LOG(0.35,2)	=-0.35*LOG(0.35,2)
Eggs	0.25	=LOG(0.25,2)	=-0.25*LOG(0.25,2)
```
![image](https://github.com/user-attachments/assets/27db376a-4f5b-465b-a69a-2e3aa79c07ad)

    or 
```
Click Option	P(x)	log2(P(x))	H(x) = -P(x) * log2(P(x))
Click "Buy Now" 	0.6	   =LOG(0.6,2)	  =-0.6*LOG(0.6,2)
Click "Learn More"	 0.3	  =LOG(0.3,2)	 =-0.3*LOG(0.3,2)
Exit Page   	0.1	   =LOG(0.1,2)	  =-0.1*LOG(0.1,2)
```
![image](https://github.com/user-attachments/assets/29222865-19e7-40f0-b846-2baa6c2e56eb)

    or
 ```
 Email Type P(x)	log2(P(x))	H(x)
Spam	 0.7	=LOG(0.7,2)	  =-0.7*LOG(0.7,2)
Not-Spam	0.3	 =LOG(0.3,2)	=-0.3*LOG(0.3,2) 
```
![image](https://github.com/user-attachments/assets/eb833def-be3f-45cf-a293-ef2793cdeea1)


































# discrete-practicals-
## practical 1 
```
class SET:
    def __init__(self, u_set):
        self.u_set = u_set

    def is_member(self, element):
        return "Element Found" if element in self.u_set else "Element Not Found"

    def powerset(self):
        lst = []
        length = len(self.u_set)
        u_list = list(self.u_set)  # Convert set to list for indexing
        for i in range(1 << length):
            lst.append({u_list[j] for j in range(length) if (i & (1 << j))})
        print("Your Required Powerset Is:", lst)

    def subset(self, subset_set):
        if subset_set.u_set.issubset(self.u_set):
            return "This Is A Subset"
        else:
            return "This Is Not A Subset"

    def union_intersection(self, set2):
        print("Intersection Of Your Sets Is:", self.u_set.intersection(set2.u_set))
        print("Union Of Your Sets Is:", self.u_set.union(set2.u_set))

    def complement(self, complement_set):
        print("Complement Of The Set Is:", self.u_set - complement_set.u_set)

    def difference_and_symmetric_difference(self, set2):
        print("Difference Of The Sets Is:", self.u_set.difference(set2.u_set))
        print("Symmetric Difference Is:", self.u_set.symmetric_difference(set2.u_set))

    def cartesian_product(self, set2):
        product = {(x, y) for x in self.u_set for y in set2.u_set}
        print("Cartesian Product Is:", product)


def set_create(uni="Set"):
    u_set = set(map(int, input(f"Enter elements of {uni} (space-separated): ").split()))
    print(f"{uni} is:", u_set)
    return u_set


def main():
    choice = input("""\nMain Menu:
1. Check whether an element belongs to the set or not
2. List all the elements of the powerset
3. Check whether one set is a subset of the other
4. Find union and intersection of two sets
5. Find complement of a set
6. Find difference and symmetric difference between sets
7. Find cartesian product of sets
Enter your choice (1–7): """)

    if choice == '1':
        set1 = SET(set_create())
        element = int(input("Enter the element to search: "))
        print(set1.is_member(element))
    elif choice == '2':
        set1 = SET(set_create())
        set1.powerset()
    elif choice == '3':
        universal_set = SET(set_create("Universal Set"))
        subset_set = SET(set_create("Subset"))
        print(universal_set.subset(subset_set))
    elif choice == '4':
        set1 = SET(set_create("First Set"))
        set2 = SET(set_create("Second Set"))
        set1.union_intersection(set2)
    elif choice == '5':
        universal_set = SET(set_create("Universal Set"))
        setA = SET(set_create("Subset"))
        universal_set.complement(setA)
    elif choice == '6':
        set1 = SET(set_create("First Set"))
        set2 = SET(set_create("Second Set"))
        set1.difference_and_symmetric_difference(set2)
    elif choice == '7':
        set1 = SET(set_create("First Set"))
        set2 = SET(set_create("Second Set"))
        set1.cartesian_product(set2)
    else:
        print("Invalid choice. Please try again.")
        main()

if __name__ == "__main__":
    for _ in range(8):
        main()
```


## practical2 
```
from numpy import array

class RELATION:
    def __init__(self, matrix):
        self.matrix = matrix
        self.length = len(matrix)

    def reflexive(self):
        for i in range(self.length):
            if not self.matrix[i][i]:
                return False
        return True

    def symmetric(self):
        for i in range(self.length):
            for j in range(self.length):
                if self.matrix[i][j] != self.matrix[j][i]:
                    return False
        return True

    def transitive(self):
        for i in range(self.length):
            for j in range(self.length):
                for k in range(self.length):
                    if self.matrix[i][j] and self.matrix[j][k] and not self.matrix[i][k]:
                        return False
        return True

    def anti_symmetric(self):
        for i in range(self.length):
            for j in range(self.length):
                if i != j and self.matrix[i][j] and self.matrix[j][i]:
                    return False
        return True


def enter_matrix():
    lst = list(map(int, input("Enter all relation matrix values (space-separated): ").split()))
    row = int(input("Enter the number of rows/columns (for square matrix): "))
    matrix = array(lst).reshape(row, row)
    print("Your matrix is:\n", matrix)
    return matrix


def main():
    rel = RELATION(enter_matrix())
    if rel.reflexive() and rel.symmetric() and rel.transitive():
        print("Your Relation is an Equivalence Relation.")
    elif rel.reflexive() and rel.anti_symmetric() and rel.transitive():
        print("Your Relation is a Partial Order Relation.")
    else:
        print("Your Relation is neither Equivalence nor Partial Order.")


if __name__ == "__main__":
    main()
```

## practical 3
```
from itertools import permutations, product

def generate_permutations(Set, repetition):
    if repetition:
        return list(product(Set, repeat=len(Set)))  # With repetition: use product
    else:
        return list(permutations(Set))  # Without repetition: use permutations

def main():
    Set = set(map(int, input("Enter all elements of the set (space-separated): ").split()))
    with_repetition = generate_permutations(Set, repetition=True)
    without_repetition = generate_permutations(Set, repetition=False)

    print("\nPermutations WITH repetition:")
    for perm in with_repetition:
        print(perm)

    print("\nPermutations WITHOUT repetition:")
    for perm in without_repetition:
        print(perm)

    print(f"\nTotal With Repetition: {len(with_repetition)}")
    print(f"Total Without Repetition: {len(without_repetition)}")

if __name__ == "__main__":
    main()
```

## prac 4
```
from itertools import product

def find_solutions(n, C):
    solutions = []
    # Generate all n-tuples with values from 0 to C (inclusive)
    for combo in product(range(C + 1), repeat=n):
        if sum(combo) == C:
            solutions.append(combo)
    return solutions

if __name__ == "__main__":
    n = int(input("Enter number of variables (n): "))
    C = int(input("Enter constant value (C ≤ 10): "))

    if C > 10 or C < 0:
        print("C must be between 0 and 10 (inclusive).")
    else:
        solutions = find_solutions(n, C)
        print(f"\nAll solutions for x1 + x2 + ... + x{n} = {C} are:")
        for sol in solutions:
            print(sol)
        print(f"\nTotal solutions found: {len(solutions)}")
```

## practical 5
```
def solve_function():
    func = list(map(int, input("Enter the coefficients of the function (highest to lowest power), separated by space: ").split()))
    num = int(input("Enter value of variable: "))
    
    value = 0
    degree = len(func) - 1
    
    for i in range(len(func)):
        value += func[i] * (num ** (degree - i))
    
    return value

# Call the function and print the result
print("Value of the function is:", solve_function())
```
## practical 6
```
def is_complete_graph(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(n):
            if i == j:
                if matrix[i][j] != 0:  # No self-loop
                    return False
            else:
                if matrix[i][j] != 1:  # All distinct pairs must be connected
                    return False
    return True

def main():
    n = int(input("Enter the number of vertices in the graph: "))
    print("Enter the adjacency matrix row by row (space-separated):")

    matrix = []
    for i in range(n):
        row = list(map(int, input(f"Row {i+1}: ").split()))
        if len(row) != n:
            print("Invalid row length. Matrix must be square.")
            return
        matrix.append(row)

    print("\nAdjacency Matrix:")
    for row in matrix:
        print(row)

    if is_complete_graph(matrix):
        print("\nThe graph is a COMPLETE graph.")
    else:
        print("\nThe graph is NOT a complete graph.")

if __name__ == "__main__":
    main()
```
## ppractical 7
```
def is_complete_graph(adj_list):
    n = len(adj_list)
    for vertex, neighbors in adj_list.items():
        if len(neighbors) != n - 1:
            return False
    return True

def main():
    n = int(input("Enter the number of vertices: "))
    adj_list = {}

    print("Enter the adjacency list for each vertex:")
    for i in range(n):
        neighbors = list(map(int, input(f"Enter neighbors of vertex {i} (space-separated): ").split()))
        adj_list[i] = neighbors

    print("\nAdjacency List:")
    for vertex in adj_list:
        print(f"{vertex}: {adj_list[vertex]}")

    if is_complete_graph(adj_list):
        print("\nThe graph is a COMPLETE graph.")
    else:
        print("\nThe graph is NOT a complete graph.")

if __name__ == "__main__":
    main()
```

## practical 8
```
class DirectedGraph:
    def __init__(self, vertices):
        self.vertices = vertices
        self.adj_list = [[] for _ in range(vertices)]

    def add_edge(self, u, v):
        # Add a directed edge from u to v
        self.adj_list[u].append(v)

    def compute_degrees(self):
        in_degree = [0] * self.vertices
        out_degree = [0] * self.vertices

        for u in range(self.vertices):
            out_degree[u] = len(self.adj_list[u])  # Count of outgoing edges
            for v in self.adj_list[u]:
                in_degree[v] += 1  # Count of incoming edges

        print("\nVertex\tIn-Degree\tOut-Degree")
        for i in range(self.vertices):
            print(f"{i}\t{in_degree[i]}\t\t{out_degree[i]}")

    def print_adj_list(self):
        print("\nAdjacency List:")
        for i in range(self.vertices):
            print(f"{i}: {self.adj_list[i]}")


# Main program
if __name__ == "__main__":
    n = int(input("Enter number of vertices: "))
    e = int(input("Enter number of directed edges: "))

    graph = DirectedGraph(n)

    for i in range(e):
        u, v = map(int, input(f"Enter edge {i+1} (from to): ").split())
        graph.add_edge(u, v)

    graph.print_adj_list()
    graph.compute_degrees()

```

outputs prac 1

![image](https://github.com/user-attachments/assets/586290f7-d4de-4989-99bb-dc1873a28471)

![image](https://github.com/user-attachments/assets/fe5e7801-c3a5-41a4-9a95-2142f8d7dfb6)


![image](https://github.com/user-attachments/assets/135866de-3c61-426f-93f5-915f55dd89de)


![image](https://github.com/user-attachments/assets/27f287d2-770c-44c8-b5f1-13ebec85f79b)


![image](https://github.com/user-attachments/assets/360bd3bc-84c8-4cf0-9bf3-5b582361de5d)


![image](https://github.com/user-attachments/assets/def49d88-1f4b-478e-944d-b1ac446fb886)


![image](https://github.com/user-attachments/assets/e1c0bd80-c643-4850-b03b-fbad918990ca)


![image](https://github.com/user-attachments/assets/ba706bdc-f785-4520-818e-24fda7b09dc6)

prac 2
![image](https://github.com/user-attachments/assets/26f60c62-3b62-4049-8812-d9119c93a80f)

![image](https://github.com/user-attachments/assets/71e048ed-93a8-4ae4-8f4e-0fec7d4c4729)

![image](https://github.com/user-attachments/assets/c39a7f31-5f1f-4225-8cda-1f47f976325f)

prac 3 
![image](https://github.com/user-attachments/assets/77e1e53b-224f-4c6c-a910-9ee9d1e11c7c)

practical 4
![image](https://github.com/user-attachments/assets/333542e9-e8e4-487e-be61-fc7cc5e32f39)

prac 5
![image](https://github.com/user-attachments/assets/ee009638-302e-4b25-96c6-9d3290ef2e28)

prac 6
![image](https://github.com/user-attachments/assets/bf612d83-c442-43ee-8461-78cfc27a1b43)
prac 7
![image](https://github.com/user-attachments/assets/f429fc4c-87f8-4732-9a21-895368cc84a4)
prac 8
![image](https://github.com/user-attachments/assets/d121fc22-d44d-41ce-ba30-12e11096e400)
```

Unit 1
Basic Probability: Introduction to the notion of probability, Random experiment, Sample space and Events, Probability defined on events, Algebra of events. Conditional probabilities, independent events, Bayes' theorem.

UNIT-II

Random Variables: Introduction to Random Variables, Probability mass/density functions, Cumulative distribution functions. Discrete Random Variables (Bernoulli, Binomial, Poisson, Multinomial and Geometric). Continuous Random Variables (Uniform, Exponential and Normal). Expectation of a Random Variable, Expectation of Function of a Random Variable and Variance. Markov inequality, Chebyshev's inequality, Central Limit Theorem, Weak and Strong Laws of Large Numbers.

UNIT-III

Joint Distributions; Jointly distributed Random Variables, Joint distribution functions, Independent Random Variables, Covariance of Random Variables, Correlation Coefficients. Conditional Expectation.

Unit 4
Markov Chain and Information Theory: Introduction to Stochastic Processes, Chapman Kolmogorov equations, Classification of states, Limiting and Stationary Probabilities. Random Number Generation, Pseudo Random Numbers, Inverse Transformation Method, Rejection Method, Uncertainty, Information and Entropy, Mutual Information, KL Divergence.

Explain all these topics with their definition and formula with examples in hinglish as tomorrow is my viva and external teacher can ask question from any of the topics and also explain if any topics have types or  parts around please explain it also., I would be very grateful  🙏

```
